# Учебник по C#

## Введение
Да, толковых учебников полным-полно, но этот учебник особенный: он берёт за основу узкоспециализированный язык QSP и медленно погружает читателя в столь тяжелый промышленный язык как C#. Что говорить, от тернии — к звездам!

Желательно изучать последовательно, а по ссылкам уже бегать, если захочется освежить память.

## Начало
Бесполезно что-то изучать без практики, потому возьмем себе такую задачку:
> Написать программу, которая просит пользователя ввести какое-нибудь число, а когда введет, пусть программа прибавит к нему единицу, а затем выведет на экран итог. Если пользователь введет какую-нибудь чепуху, то попросить, чтобы ввел число.

Такая задача проста и сходу затрагивает основные компоненты программирования:
* Переменные
* Ввод-вывод
* Операторы
* Условия (они же ветвления)
* Циклы
И это решение можно оформить в подпрограмму ("локация", если говорить языком QSP'а), но это так, бонус.

Запомните эту задачу и по мере изучения постепенно старайтесь ее решить. Раз уж вы знакомы с QSP'ом, то можете написать алгоритм на нем, а затем транслировать код в C#.

В качестве редактора лучше всего использовать [Visual Studio](https://visualstudio.microsoft.com/);
* Но если места нет, то можно использовать легковесный [Visual Studio Code](https://code.visualstudio.com/) и прикрутить к нему [расширение C#](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp);
    [Тут](https://docs.microsoft.com/en-us/dotnet/core/tutorials/with-visual-studio-code) толковая инструкция, как создать и запустить консольный проект, к сожалению, на английском.
* Если совсем всё плохо, то можно использовать какой-нибудь онлайн-редактор вроде [этого](https://www.onlinegdb.com/online_csharp_compiler), но у них отсутствуют такие полезные инструменты (особенно, для начинающих), как: проверка синтаксиса налету, подсказки, символьное автозавершение, сигнатуры методов и т.п. Используйте лучше VS или VS Code с расширением и не мучайтесь.

<!-- dotnet new console -o HelloWorld -->

В качестве шаблона возьмем файл HelloWorld.cs:
```csharp
namespace HelloWorld
{
    class Hello {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello World!");

            // Да, я знаю, выглядит пока страшно и непонятно,
            // но пока закроем глаза на детали
            // и основной код будем писать исключительно тут

            // (т.е. строго говоря, в теле статического метода `Main`,
            //  в классе `Hello`, в пространстве `HelloWorld`,
            //  но с этими дебрями мы познакомимся постепенно)
        }
    }
}
```

Итак, всё начинается с переменных.

## Переменные
В QSP можно присваивать одной и той же переменной как строковый тип данных, так и числовой:
```qsp
x = 42
x = "строка"
```
Это называется *динамическая* типизация, и она в C# не прокатывает, поскольку C# язык со *статической* типизацией.

В C# сначала объявляется тип данных, а потом — имя переменной:
```csharp
int numericalVar; // int — это числовой целочисленный тип (о целочисленных и вещественных потом как-нить)
string stringVar; // string — строковый тип данных
```
(Точка с запятой обязательно ставится после каждой инструкции, иначе обругает)


Объявили тип, а теперь можно использовать:
```csharp
numericalVar = 10; // норм
numericalVar = 42; // и это норм
numericalVar = "10"; // а вот здесь уже заорет, потому что не совпадают типы данных
stringVar = "blah";
stringVar = 42; // и здесь заорет, потому что ожидается строковый тип, а никак не числовой
```

Кстати, для простоты можно одновременно объявить тип и присвоить значение:
```csharp
string stringVar = "foo";
int numericalVar = 42;
```

Стоит отметить, что нельзя повторно объявить переменную, т.е. такое не прокатывает:
```csharp
string stringVar;
int stringVar;

// такое упадет:
string stringVar = "foo";
int stringVar = 42;
```

Ах да, присвоение переменных тоже работает согласно типизации, т.е.:
```csharp
string stringVar1 = "foo";
string stringVar2 = stringVar1;

int numVar1 = 42;
int numVar2 = 10;
numVar1 = numVar2;

// а вот это уже заорет, потому что ожидается `int`, а ему на вход подается `string`
numVar1 = stringVar1;
```

* [Про преобразование типов](#преобразование-типов)
* [Про операторы](#операторы)
* [Про область видимости переменных](#область-видимости-переменных)

### Автоматическое выведение типа данных
Дабы не не указывать каждый раз тип, существует механизм автоматического выведения типа на основе его значения. Действует она так:
```csharp
var stringVar = "строковое значение"; // внимание на `var`
var numericVar = 42;

stringVar = "foo";
numericVar = 10;
```

Кстати, не уверен, что так можно:
```csharp
var stringVar;
stringVar = "строка";
```
Так что, вот вам задание это выяснить.

Лично я пока советую указывать типы **явно**, чтобы к ним привыкнуть.

```csharp
string strVar = "строковая переменная";
int numVar = 42;
```

## Ввод и вывод
Ну, эт просто, если не вдаваться в детали, конечно.

### Вывод
QSP:
```
"Патронов осталось: <<ammoCount>>\nАптечек: <<medicalKitsCount>>"
```

C#:
```csharp
// либо так:
System.Console.WriteLine("Патронов осталось: {0}\nАптечек: {1}", ammoCount, medicalKitsCount);
// либо через строковую интерполяцию (string interpolation). Да именно так называется способ подстановки в QSP'е:
System.Console.WriteLine($"Патронов осталось: {ammoCount}\nАптечек: {medicalKitsCount}");
```

### Ввод
QSP:
```
$name = $INPUT('Как звать тебя, герой?')
```

```csharp
System.Console.WriteLine("Как звать тебя, герой?");
string name = System.Console.ReadLine();
```

## Ветвления
QSP:
```qsp
if expr:
    ; ...
else:
    ; ...
```

C#:
```csharp
if (expr) {
    // ...
} else {
    // ...
}
```

Тут мы знакомимся с новым типом данных `bool`, он же булев тип данных. В QSP для выполнения условия входное выражение (оно же `expr`) в итоге должно иметь значение `0`, а от всех остальных значений срабатывает инструкции в теле `else`, если таковое вообще имеется.
Такой подход не то, чтобы плох, но что-то в нем не так. Логично (пардон, за каламбур), что мы работаем с двумя значениями `истина` и `ложь`: при истинном значении случается то-то, а при ложном это. Вот и булев тип вмещается в себя ровно два этих значения. Выглядит это так:
```csharp
bool universeIsEndless = true;
if (universeIsEndless) {
    // вселенная бесконечна — это истина, ну, по крайней мере, согласно какой-то гипотезе... В общем, пусть будет так, лады?
}

bool earthIsFlat = false;
if (earthIsFlat) {
    // Вы таки утверждаете, что Земля плоская? Вы точно в этом уверены?
} else {
    // Земля плоская — это утверждение ложно
}
```

Еще существует switch case, но о нем потом как-нибудь.

### Логические операторы
* Логическое НЕ: `!:(bool) => bool`
    > Эта запись — сигнатура функции (да, оператор — это функция). Читать ее надо так: название фукции до двоиточия, затем в скобках перечисляются типы аргументов, а после `=>` тип возвращаемого значения. Это всё станет понятно после изучения [подпрограммы](#подпрограммы)

    ```csharp
    bool x = true;
    bool inverseX = !x;
    System.Console.WriteLine($"inverseX = {inverseX}, т.е. false");
    ```
* Логическое И: `&&: (bool, bool) => bool`
* Логическое ИЛИ: `||: (bool, bool) => bool`
<!-- `x == y` — если `x` истинно и `y` истинно, тогда истина
`x != y`
`!x` -->

<!-- Про работу с булевым типом поговорим [тут]() -->

## Область видимости переменных
Раз уж нас появился первый конструктор `if`, то пришло время рассказать про область видимости переменных (variable scope).

В QSP'е почти все переменные глобальны, т.е. из одной локации можно достучаться до переменной в другой, но есть всё же локальные переменные, и находятся они в `args`, т.е. у каждой локации — свой `args`

<!-- TODO: рассуждения о том, почему глобальные переменные — это плохо -->
Примерно та же идея распространяется на каждый конструктор в C#
```csharp
int x = 42;

if (true) {
    string y = "ответ на вопрос вселенной и всего такого — " + x.ToString(); // здесь `x` как бы проваливается во вложенное тело

    string x = "43"; // выбьет ошибку, потому что нельзя перезаписывать объявлять переменную с таким же именем, хотя она и в новом контексте
    x = 40; // а вот присвоить ей что-то — эт пожалуйста
}

System.Console.WriteLine($"x = {x}, т.е. 40");

System.Console.WriteLine($"y = {y}"); // выбьет ошибку, потому что `y` не существует в текущем контексте
```

Кстати, можно создать тело без ничего только ради области видимости:
```csharp
int x = 42;

{
    string y = "ответ на вопрос вселенной и всего такого — " + x.ToString();
    x = 40;
}

System.Console.WriteLine($"x = {x}, т.е. 40");

System.Console.WriteLine($"y = {y}"); // выбьет ошибку, потому что `y` не существует в текущем контексте
```


## Слабая типизация против сильной
<!-- Этот раздел расширяет [преобразованием типов](#преобразование-типов), только в этот раз показывает операторах лучше всего показать разницу между слабой типизацией и сильной. -->
Проще всего показать эту разницу на операторах, хотя мы про них еще не говорили. QSP слабо типизирован, поскольку допускает такое:
```qsp
x = "10"
y = 20
x + y
```
В итоге выведет 30, вроде просто, да? А что в таком случае получим:
```qsp
x = "сорок два"
y = 20
x + y
```
<!-- TODO: а что получим-то? -->
Конечно, можно явно преобразовать через соответствующую функцию, и она, возможно, закричит во время исполнения, что случилась какая-то ерунда. Но в C# такое считается ошибкой и ловится на этапе компиляции.

Про JS часто шутят в духе:
![](https://cdn.discordapp.com/attachments/715134697729949726/758601860369219624/147393909915812096.jpg)

В этом и кроется главная проблема слаботипизированных языков. Да, можно в спецификации выучить, к чему приводит то или иное сочетание (как эта барышня, ага), а то и вовсе их избегать от греха подальше, но такой подход в любом случае требует внимательности. А зачем, когда можно на этапе компиляции исправить такие ошибки?

Т.е. у C# тот же `+` ведет себя так:
```csharp
string a = "a";
string b = "b";
string ab = a + b; // тут всё замечательно
```

```csharp
int x = "10";
int y = y + 20; // выбьет ошибку, потому что нельзя прибавить `int` к `string`
```
Или ошибка со строкой:
```csharp
int x = 10;
string y = x + "something"; // тоже выбьет ошибку
```

Чтобы всё-таки что-то к чему-то прибавить, нужно научиться преобразовывать типы, об этом читаем дальше.

## Преобразование типов

### Числовой тип в строковый, и наоборот
`int` в `string` преобразовать достаточно легко:
```csharp
int ammo = 10;
string ammoString = ammo.ToString();
```

А вот преобразование из `string` в `int` вызывает множество вопросов: что если на вход подать такую белиберду `2345asdf`? Отсечь первые цифры, а остальное откинуть? Или выбить ошибку?

Простейшая функция, которая точно переводит из строки в число — `System.Int32.Parse`. Т.е. она сгрызет следующее:
```csharp
int ammo = System.Int32.Parse("42");
```

Либо через переменную
```csharp
string input = "350";
int ammo = System.Int32.Parse(input);
```

А вот тут уже зубки обломает и выбьет т.н. исключение (exception):
```csharp
int ammo = System.Int32.Parse("something");
```

И тут выбьет, потому что неясно, как это интерпретировать:
```csharp
int ammo = System.Int32.Parse("42 is answer of...");
```

Когда выбивает исключение, программа останавливается, и больше ее не сдвинуть. Так, что же делать, если пользователь вводит ошибочные данные? Здесь есть два пути: либо [обработать исключение](), либо воспользоваться, э-э... Я не знаю, как это точно называется, но при проектировании программ обрабатывать исключения нужно, когда возможные ошибки слишком разнообразны. Это довольно глубокая тема, и относится, скорее, к проектированию систем, чем к механизмам языка.

В общем, в данном случае (т.е. когда нужно обработать именно числовые данные) в C# существует особенная функция `System.Int32.TryParse`, которая используется так:

```csharp
string input = System.Console.ReadLine();
int result;
if (System.Int32.TryParse(input, out result)) {
    System.Console.WriteLine($"Число преобразовалось удачно и сохранилось в переменную `result` со значением {result}");
} else {
    System.Console.WriteLine($"Ошибка при преобразовании {input}");
}
```

Более подробно про ключевое слово `out` поговорим в разделе [подпрограммы](#подпрограммы), а пока воспринимайте интуитивно и как есть :wink:


## Операторы сравнения


<!-- Оператор по сути своей — это функция, только используется немного иначе: если функция вызывается так `Add(x, y)`, то оператор вызывается так `x + y`. -->
<!-- А еще их можно переопределять -->

<!-- В общем, в этом разделе проще перечислить то, какие операторы бывают -->

* `==` (x равно y) берёт два значения, сравнивает их и выводит `bool` (`=` — аналог на QSP'е)
    Сигнатуры:
    * `(int, int) => bool`
    * `(string, string) => bool`
    * и т.д.

    Надо запомнить лишь, что можно сравнивать один тип с таким же
* `!=`, он же x не равно y (`!` или `<>` — аналог на QSP'е)

## Циклы

### While

Для цикла в QSP'е используется jump, он же goto, и это плохо, как говорил Дейкстра

<!-- TODO: (да-да, ссылка на авторитет — самое то, чтобы подкрепить свой аргумент). Потом распишу, почему это плохо, а пока  -->
<!-- TODO: краткий экскурс в структурное программирование -->
Goto есть в C#, но лучше бы не было.

Вместо него используются другие конструкторы более высокого порядка, чем скакание по коду — `while`, `do...while`, `for`, `foreach`

* `while`
    Реализация на QSP'е:
    ```qsp
    :label
    if expr:
        ; ...
        jump label
    ```

    На C#:
    ```csharp
    while (expr) {
        // ...
    };
    ```

    Мотает до тех пор, пока `expr` не станет `false`.

    Главное отличие в подходах — `while` — это полноценный конструктор, а значит, там действуют законы [видимости переменных](#область-видимости-переменных).
    <!-- Если на `while` особо не существенно, то вот `for` это очень сильно сказывается. Об этом ниже. -->
* `do...while`
    `while` сперва проверяет `expr`, а потом уже действует.
    ```csharp
    while (false) {
        // это тело никогда не выполнится
    };
    ```

    Если нужно сначала действовать, а потом проверять, то `do...while` — это ваш выбор:

    ```csharp
    bool expr = false;
    do {
        System.Console.WriteLine("сперва действуем, а потом проверяем");
    } while (expr);
    ```
* `for`
    Эта штука выросла из задачи: как посчитать от 1 до 10?

    На QSP'е это выглядело бы так:
    ```qsp
    i = 1
    :loop
    if i <= 10:
        i
        i += 1
        jump loop
    ```

    Через `for` на C# это выглядит так:
    ```csharp
    for (int i = 1; i <= 10; i++) {
        System.Console.WriteLine(i);
    }
    ```

* `foreach` разберем, когда дойдем до массивов и прочих последовательностей, собственно, он ради этого и предназначен, чтобы перечислить цепочку значений

Кстати, существует инструкция `break`, которая позволяет выйти из любой точки цикла, т.е. всех этих конструкций.

## Первая задача
Должно быть, я вас перегрузил, но этих знаний теперь точно хватит, чтобы решить поставленную задачу.


## Подпрограммы

<!-- TODO -->